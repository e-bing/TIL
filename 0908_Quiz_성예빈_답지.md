##### 1. 데이터베이스의 기본

(1) 엔터티

(2) 릴레이션

(3) 속성

(4) 도메인



##### 2. 필드 타입

`(2)`

(1) 해당 설명은 `DATETIME` 에 관한 설명이고, `DATE` 는 날짜 부분만 있고 시간 부분이 없는 값에 사용된다.

(3) 글자 수를 정하는 타입은 `CHAR` 과 `VARCHAR` 두 가지이다.

(4) `VARCHAR` 은 10글자를 저장할 경우 글자 수에 해당하는 바이트 + 길이 기록용 1바이트의 크기로 저장된다.



##### 3. 필드 타입 2

(a) TEXT

(b) BLOB

(c) ENUM

(d) SET



##### 4. 키

`(3)`

자연 키는 언젠가 변하는 속성을 가진다.



##### 5. 데이터베이스의 구축

ERD(Entity Relationship Diagram)



##### 6. 정규화 과정

(1) 릴레이션의 모든 도메인이 더이상 분해될 수 없는 원자 값으로 구성되어야 한다. 릴레이션의 속성 값 중에서 한 개의 기본키에 대해 두 개 이상의 값을 가지는 반복 집합이 있어서는 안 되며, 반복 집합이 존재하면 제거해야 한다.

(2) 릴레이션이 제1정규형이며 부분 함수의 종속성을 제거한 형태를 말한다. 부분 함수의 종속성 제거란 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것을 말한다. 릴레이션을 분해할 때 동등한 릴레이션으로 분해해야 하고, 정보 손실이 발생하지 않는 무손실 분해가 이루어져야 한다.

+ 함수 종속 : 중복이 있을 수 있는 속성이 결정자 속성에 의해 식별되는 것이다. 어떤 속성이 모든 결정자를 필요로 할 경우 함수 완전 종속이라 하고, 일부만 있어도 식별이 가능한 경우 부분 함수 종속이라고 한다. 제2정규형에서는 이 부분 함수 종속을 별도의 개체로 분리하는 과정이다.

(3) 제2정규형이고, 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태를 말한다. 이행적 함수 종속이란 A -> B와 B -> C가 존재하면 논리적으로 A -> C가 성립하는데, 이때 집합 C가 집합 A에 이행적 함수 종속이 되었다고 표현한다.



##### 7. 보이스/코드 정규형

예를 들어 학생아이디, 과목명, 교수아이디 속성을 가진 릴레이션이 있을 때, 기본키는 학생아이디와 과목명이다. (학생아이디, 과목명)은 교수아이디를 결정할 수 있다. 한 명의 학생이 듣는 특정 과목의 교수 아이디는 단 하나이기 때문이다. 여기서 수강생이 없는 과목명이나 교수아이디는 삽입이 불가능한 문제(삽입 이상) 등등을 해결해야 한다.

릴레이션을 (학생아이디, 과목명), (과목명, 교수아이디)로 나누는 것이다.



##### 8. 트랜잭션

`(4)`

(1) 외부 API 호출이 있으면 안 된다.

(2) 트랜잭션 전파를 신경 써서 관리해야 한다.

* 트랜잭션 전파는 어떤 트랜잭션이 동작 중인 과정에서 다른 트랜잭션을 실행할 경우 어떻게 처리하는가에 대한 개념이다. 여러 트랜잭션 관련 메서드의 호출을 하나에 묶이도록 하는 것이다.

(3) 변경된 내용이 영구적으로 저장된다.



##### 9. ACID 특징

(1) 지속성

(2) 격리성

(3) 일관성



##### 10. 격리 수준

(1) 가장 많이 사용되는 격리 수준이며, 다른 트랜잭션이 커밋하지 않은 정보는 읽을 수 없다. 하지만 어떤 트랜잭션이 접근한 행을 다른 트랜잭션이 수정할 수 있으므로, 같은 행을 다시 읽을 때 다른 내용이 발견될 수 있다.

(2) 한 트랜잭션 내의 같은 행에 두 번 이상 조회가 발생했는데, 그 값이 다른 경우를 가리킨다.

(3) 트랜잭션을 순차적으로 진행시키는 것이다. 여러 트랜잭션이 동시에 같은 행에 접근할 수 없다. 교착 상태가 일어날 확률이 많고, 가장 성능이 떨어진다.

(4) 한 트랜잭션 내에서 동일한 쿼리를 보냈을 때 해당 조회 결과가 다른 경우이다. 이전과 다른 행이 선택될 수도 있다는 것을 의미한다.

(5) 하나의 트랜잭션이 수정한 행을 다른 트랜잭션이 수정할 수 없지만, 새로운 행을 추가하는 것은 막지 않는다. 그러므로 이후에 추가된 행이 발견될 수도 있다.




