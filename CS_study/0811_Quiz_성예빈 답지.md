##### 1. 시간 복잡도와 Big-O 표기법

연산의 수행횟수는 1+ 2 + 3 + ... + n-1이므로, S_n = n * (n - 1) / 2이다.

1부터 n-1이므로 첫번째 항이 0이고 공차가 1인 등차수열의 a_n까지의 합이라고 생각할 수 있기 때문이다. 또는 첫번째 항이 1이고 공차가 1인 등차수열의 a_n-1까지의 합이라고 생각할 수도 있다. 그래도 (n-1) * (2 + n-2) / 2 이므로 결국 결과는 같다.

따라서 Big-O 표기법으로 나타내면 O(n^2)이다.

##### 2. 공간 복잡도

(1) O(n^2)

(2) O(1)

##### 3. 연결 리스트

(4) head의 prev 포인터는 null을 가리킨다.

##### 4. 배열

(3) 배열 내 원소들의 메모리 위치는 연속적이다.

##### 5. 벡터

데이터 크기가 커졌을 경우 메모리 할당, 복사, 해제에 너무 많은 비용이 든다고 할 수 있다. 메모리 오버헤드 또는 성능저하를 야기할 수 있다. 삽입과 삭제가 빈번히 일어날 경우에 적합하지 않다. 또는 잉여 메모리 공간이 너무 많을 수 있다 등등

##### 6. 스택과 큐

(1) 큐

(2) 스택

(3) 큐

(4) 스택

(5) 스택

(6) 큐

##### 7. 이진 탐색 트리

(a) 두 개

(b) 노드 값보다 큰 값

(c) 노드 값보다 작은 값

##### 8. 포화 이진 트리

노드의 개수는 2^(k-1)개이므로, 2^99 = 6.338253e+29

##### 9. 레드 블랙 트리

<img title="" src="https://ifh.cc/g/L47Gf6.png" alt="">

https://www.cs.usfca.edu/~galles/visualization/RedBlack.html

(1) a - black, 5

(2) a - black, 5

    b - red, 3

(3) b - red, 3

(4) b - black, 3

    d - red, 8

(5) b - black, 3

    e - red, 2

##### 10. 자료구조 정리

(1) 셋

(2) 우선순위 큐

(3) 해시 테이블

(4) 맵
